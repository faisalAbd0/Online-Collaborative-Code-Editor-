package com.example.projects.dto;


import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class TokenValidationResponse {
    private Long userId;
}
package com.example.projects.dto;

import lombok.Data;

@Data


public class CodeEditMessage {
    private String projectId;
    private String filename;
    private String content;
    private Long userId;
    private String timestamp;
}
package com.example.projects.dto;


import lombok.Data;

@Data
public class TokenValidationRequest {
    private String token;
}
package com.example.projects.repository;

import com.example.projects.models.CodeProject;
import org.springframework.data.jpa.repository.JpaRepository;


import java.util.List;
import java.util.Optional;

public interface CodeFileRepository
        extends JpaRepository<CodeProject, Long> {

    Optional<CodeProject> findByUserId(Long userId);
    Optional<List<CodeProject>> findAllByUserId(Long userId);
}
package com.example.projects.websocket;

import com.example.projects.dto.CodeEditMessage;
import lombok.RequiredArgsConstructor;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.SendTo;
import org.springframework.stereotype.Controller;

@Controller
@RequiredArgsConstructor
public class CodeEditController {

    @MessageMapping("/edit") // client sends to /app/edit
    @SendTo("/topic/updates") // server broadcasts to /topic/updates
    public CodeEditMessage broadcastChange(CodeEditMessage message) {
        System.out.println("Received edit: " + message);
        return message; // Automatically broadcast to all subscribers
    }
}
package com.example.projects.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.*;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        config.enableSimpleBroker("/topic"); // For broadcasting
        config.setApplicationDestinationPrefixes("/app"); // For sending
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws") // WebSocket endpoint
                .setAllowedOriginPatterns("*")
                .withSockJS(); // Use SockJS fallback
    }
}
package com.example.projects.config;

import com.example.projects.models.CodeProject;
import com.example.projects.models.Language;
import com.example.projects.repository.CodeFileRepository;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.MediaType;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.web.client.RestTemplate;

import java.time.LocalDateTime;
import java.util.Arrays;

@Configuration
public class AppConfig {

    @Bean
    CommandLineRunner commandLineRunner(CodeFileRepository codeFileRepository) {
        return args -> {
            // Only run this if the database is empty
            if (codeFileRepository.count() == 0) {
                CodeProject codeFile = new CodeProject(
                        "CodeEditor",
                        "Java",
                        Language.Java,
                        LocalDateTime.now(),
                        1L
                );
                CodeProject codeFile1 = new CodeProject(
                        "ML AI",
                        "Python",
                        Language.Python,
                        LocalDateTime.now(),
                        1L
                );

                CodeProject codeFile2 = new CodeProject(
                        "CodeEditor",
                        "Java",
                        Language.Java,
                        LocalDateTime.now(),
                        2L
                );
                CodeProject codeFile3 = new CodeProject(
                        "ML AI",
                        "Python",
                        Language.Python,
                        LocalDateTime.now(),
                        2L
                );

                CodeProject codeFile4 = new CodeProject(
                        "CodeEditor",
                        "Java",
                        Language.Java,
                        LocalDateTime.now(),
                        3L
                );
                CodeProject codeFile5 = new CodeProject(
                        "ML AI",
                        "Python",
                        Language.Python,
                        LocalDateTime.now(),
                        3L
                );

                codeFileRepository.save(codeFile);
                codeFileRepository.save(codeFile1);
                codeFileRepository.save(codeFile2);
                codeFileRepository.save(codeFile3);
                codeFileRepository.save(codeFile4);
                codeFileRepository.save(codeFile5);
            }
        };
    }

    @Bean
    RestTemplate restTemplate() {
//        return new RestTemplate();

        RestTemplate restTemplate = new RestTemplate();
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        converter.setSupportedMediaTypes(Arrays.asList(MediaType.APPLICATION_JSON, MediaType.TEXT_HTML));
        restTemplate.getMessageConverters().add(converter);
        return restTemplate;

    }
}package com.example.projects.config;


import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;

import java.util.Arrays;


@EnableWebMvc
@Configuration
public class CorsConfig {

    @Bean
    public FilterRegistrationBean<CorsFilter> corsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();

        config.setAllowCredentials(true);
        config.setAllowedOrigins(Arrays.asList("http://localhost:3000"));
        config.setAllowedHeaders(Arrays.asList(
                HttpHeaders.AUTHORIZATION,
                HttpHeaders.CONTENT_TYPE,
                HttpHeaders.ACCEPT
        ));
        config.setAllowedMethods(Arrays.asList(
                HttpMethod.GET.name(),
                HttpMethod.POST.name(),
                HttpMethod.PUT.name(),
                HttpMethod.PATCH.name(),
                HttpMethod.DELETE.name()
        ));
        config.setMaxAge(3600L); // 1 hour

        source.registerCorsConfiguration("/**", config);

        FilterRegistrationBean<CorsFilter> registrationBean = new FilterRegistrationBean<>(new CorsFilter(source));
        registrationBean.setOrder(-102);

        return registrationBean;
    }
}

package com.example.projects.models;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.RequiredArgsConstructor;
import lombok.ToString;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Data
@Entity
@Table(name = "code_projects")
@NoArgsConstructor
@ToString
public class CodeProject {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String projectName;
    private String description;

    @Enumerated(EnumType.STRING)
    private Language language;

    private LocalDateTime createdAt;

    private Long userId;

    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    @JoinColumn(name = "project_id")
    private List<CodeFile> files = new ArrayList<>();

    public CodeProject(String projectName, String description, Language language,
                       LocalDateTime createdAt, Long userId) {
        this.projectName = projectName;
        this.description = description;
        this.language = language;
        this.createdAt = createdAt;
        this.userId = userId;
    }

    public CodeProject(String projectName, String description, Language language,
                       Long userId) {
        this.projectName = projectName;
        this.description = description;
        this.language = language;
        this.userId = userId;
    }

    public void addFile(CodeFile file) {
        if (files == null) {
            files = new ArrayList<>();
        }
        files.add(file);
    }
}package com.example.projects.models;

import jakarta.persistence.Embeddable;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Embeddable
public class CodeVersion {
    private String content;
    private String editedBy; // or Long userId
    private LocalDateTime timestamp;
    private String message; // Optional: "Initial version", "Updated after fix", etc.
}
package com.example.projects.models;

public enum Language {
    Python,
    Java,
    Cpp,
    C
}
package com.example.projects.models;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@ToString
@Table(name = "code_files")
public class CodeFile {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String filename;

    @Column(columnDefinition = "TEXT")
    private String content;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    @ElementCollection
    private List<CodeVersion> history = new ArrayList<>();

    public CodeFile(String filename, String content) {
        this.filename = filename;
        this.content = content;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    public void addVersion(String userId) {
        if (history == null) {
            history = new ArrayList<>();
        }
        history.add(new CodeVersion(content, userId, LocalDateTime.now(), "Auto snapshot"));
    }

}package com.example.projects.controller;

import com.example.projects.dto.TokenValidationRequest;
import com.example.projects.dto.TokenValidationResponse;
import com.example.projects.models.CodeFile;
import com.example.projects.models.CodeProject;
import com.example.projects.models.CodeVersion;
import com.example.projects.service.CodeFileService;
import com.fasterxml.jackson.core.JsonProcessingException;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/api/code-file")
@RequiredArgsConstructor
@CrossOrigin
        (origins =
        "http://localhost:3000")
public class CodeFileController {
    final CodeFileService codeFileService;

    @PostMapping("/user-projects")
    public List<CodeProject> findProjectsByToken(
            @RequestBody TokenValidationResponse tokenValidationResponse
    ) {

        Long userId = tokenValidationResponse.getUserId();
        System.out.println(">>>>>>>");
        System.out.println(userId);
        System.out.println("<<<<<<<");
        Optional<List<CodeProject>> code = codeFileService.findUserProject(userId);
        if (code.isEmpty()) {
            return new ArrayList<>();
        }
        return code.get();
    }

    @GetMapping("/project/{id}")
    public ResponseEntity<CodeProject> findProjectById(
            @PathVariable String id
    ){
        Optional<CodeProject> project =codeFileService.findById(id);
        if (project.isEmpty()) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(project.get());
    }
    @PostMapping("/save")
    public ResponseEntity<CodeProject> save(@RequestBody CodeProject codeProject) {
        // Ensure we have a created date
        if (codeProject.getCreatedAt() == null) {
            codeProject.setCreatedAt(java.time.LocalDateTime.now());
        }

        CodeProject savedProject = codeFileService.save(codeProject);
        return ResponseEntity.ok(savedProject);
    }

    @PostMapping("/{projectId}/files")
    public ResponseEntity<CodeProject> addFile(
            @PathVariable String projectId,
            @RequestBody CodeFile file) {
        System.out.println(projectId);
        System.out.println(file);
        return codeFileService.addFileToProject(projectId, file)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @PutMapping("/{projectId}/files/{filename}")
    public ResponseEntity<CodeProject> updateFile(
            @PathVariable String projectId,
            @PathVariable String filename,
            @RequestBody Map<String, String> update
    ) {


        String content = update.get("content");
        String userId = update.get("userId"); // 👈 userId is passed directly from the frontend

        System.out.println("Updating file for userId: " + userId);
        System.out.println("The content is: " + content);
        return codeFileService.updateFile(projectId, filename, content, userId)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }


    @DeleteMapping("/{projectId}/files/{filename}")
    public ResponseEntity<Void> deleteFile(
            @PathVariable String projectId,
            @PathVariable String filename) {
        boolean deleted = codeFileService.deleteFile(projectId, filename);
        return deleted ? ResponseEntity.ok().build() : ResponseEntity.notFound().build();
    }


    @GetMapping("/{projectId}/files/{filename}/history")
    public ResponseEntity<List<CodeVersion>> getFileHistory(
            @PathVariable String projectId,
            @PathVariable String filename
    ) {
        Optional<CodeProject> projectOpt = codeFileService.findById(projectId);
        if (projectOpt.isPresent()) {
            for (CodeFile file : projectOpt.get().getFiles()) {
                if (file.getFilename().equals(filename)) {
                    return ResponseEntity.ok(file.getHistory());
                }
            }
        }
        return ResponseEntity.notFound().build();
    }



}
package com.example.projects.controller;

import com.example.projects.dto.TokenValidationResponse;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

@Service
@RequiredArgsConstructor
@RestController
public class JwtApiService {

    private final RestTemplate restTemplate;

    public Long callJwtApi(String token) {
        HttpHeaders headers = new HttpHeaders();
//        headers.setBearerAuth(token); // OR .set("Authorization", "Bearer " + token);
        HttpEntity<TokenValidationResponse> entity = new HttpEntity<>(headers);

        System.out.println("Calling JWT API");
        ResponseEntity<TokenValidationResponse> response = restTemplate.exchange(
                "http://backend:8080/api/jwt/isValid?token=" + token, // Add token as query param
                HttpMethod.GET,
                entity,
                TokenValidationResponse.class
        );
        System.out.println("Done calling JWT API");
        System.out.println("Resonspe.getStatus(): " + response.getStatusCode());
        System.out.println("Resonspe.getBody(): " + response.getBody());

        return response.getBody().getUserId();

    }


}
/*
@Service
@RequiredArgsConstructor
public class JwtApiService {

    private final RestTemplate restTemplate;

    public String callJwtApi(String token) {
        HttpHeaders headers = new HttpHeaders();
        headers.setBearerAuth(token); // This is correct if you want to send as Authorization header
        HttpEntity<String> entity = new HttpEntity<>(headers);

        System.out.println("Calling JWT API");
        ResponseEntity<String> response = restTemplate.exchange(
                "http://localhost:8080/api/jwt/isValid?token=" + token, // Add token as query param
                HttpMethod.GET,
                entity,
                String.class
        );
        System.out.println("Done calling JWT API");
        System.out.println("Response.getStatus(): " + response.getStatusCode());
        System.out.println("Response.getBody(): " + response.getBody());

        return response.getBody();
    }
}
 */package com.example.projects;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ProjectsApplication {

	public static void main(String[] args) {
		SpringApplication.run(ProjectsApplication.class, args);
	}

}
//package com.example.projects.service;
//
//import com.example.projects.models.CodeFile;
//import com.example.projects.models.CodeProject;
//import com.example.projects.repository.CodeFileRepository;
//import lombok.RequiredArgsConstructor;
//import org.springframework.stereotype.Service;
//
//import java.time.LocalDateTime;
//import java.util.List;
//import java.util.Optional;
//
//@Service
//@RequiredArgsConstructor
//public class CodeFileService {
//    private final CodeFileRepository codeFileRepository;
//
//    public List<CodeProject> findAll() {
//        return codeFileRepository.findAll();
//    }
//
//    public Optional<CodeProject> findById(String id) {
//        System.out.println(codeFileRepository.findById(id));
//        return codeFileRepository.findById(id);
//    }
//
//    public CodeProject save(CodeProject codeFile) {
//        return codeFileRepository.save(codeFile);
//    }
//
//    public Optional<CodeProject> addFileToProject(String projectId, CodeFile file) {
//        Optional<CodeProject> projectOpt = codeFileRepository.findById(projectId);
//
//        if (projectOpt.isPresent()) {
//            CodeProject project = projectOpt.get();
//
//            // Check if file with same name already exists
//            boolean fileExists = project.getFiles().stream()
//                    .anyMatch(existingFile -> existingFile.getFilename().equals(file.getFilename()));
//
//            if (!fileExists) {
//                // Set creation time
//                if (file.getCreatedAt() == null) {
//                    file.setCreatedAt(LocalDateTime.now());
//                }
//                if (file.getUpdatedAt() == null) {
//                    file.setUpdatedAt(LocalDateTime.now());
//                }
//
//                project.addFile(file);
//                return Optional.of(codeFileRepository.save(project));
//            }
//        }
//
//        return Optional.empty();
//    }
//
//    public Optional<CodeProject> updateFile(String projectId, String filename, String newContent) {
//        Optional<CodeProject> projectOpt = codeFileRepository.findById(projectId);
//
//        if (projectOpt.isPresent()) {
//            CodeProject project = projectOpt.get();
//
//            for (CodeFile file : project.getFiles()) {
//                if (file.getFilename().equals(filename)) {
//                    file.setContent(newContent);
//                    file.setUpdatedAt(LocalDateTime.now());
//                    return Optional.of(codeFileRepository.save(project));
//                }
//            }
//        }
//
//        return Optional.empty();
//    }
//
//    public boolean deleteFile(String projectId, String filename) {
//        Optional<CodeProject> projectOpt = codeFileRepository.findById(projectId);
//
//        if (projectOpt.isPresent()) {
//            CodeProject project = projectOpt.get();
//            boolean removed = project.getFiles().removeIf(file -> file.getFilename().equals(filename));
//
//            if (removed) {
//                codeFileRepository.save(project);
//                return true;
//            }
//        }
//
//        return false;
//    }
//
//    public Optional<List<CodeProject>> findUserProject(Long id) {
//        System.out.println(codeFileRepository.findAllByUserId(id));
//        return codeFileRepository.findAllByUserId(id);
//    }
//}
package com.example.projects.service;

import com.example.projects.models.CodeFile;
import com.example.projects.models.CodeProject;
import com.example.projects.repository.CodeFileRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class CodeFileService {
    private final CodeFileRepository codeFileRepository;

    public List<CodeProject> findAll() {
        return codeFileRepository.findAll();
    }

    public Optional<CodeProject> findById(String id) {
        try {
            Long longId = Long.parseLong(id);
            return codeFileRepository.findById(longId);
        } catch (NumberFormatException e) {
            return Optional.empty();
        }
    }

    public CodeProject save(CodeProject codeFile) {
        return codeFileRepository.save(codeFile);
    }

    @Transactional
    public Optional<CodeProject> addFileToProject(String projectId, CodeFile file) {
        try {
            Long longId = Long.parseLong(projectId);
            Optional<CodeProject> projectOpt = codeFileRepository.findById(longId);

            if (projectOpt.isPresent()) {
                CodeProject project = projectOpt.get();

                // Check if file with same name already exists
                boolean fileExists = project.getFiles().stream()
                        .anyMatch(existingFile -> existingFile.getFilename().equals(file.getFilename()));

                if (!fileExists) {
                    // Set creation time
                    if (file.getCreatedAt() == null) {
                        file.setCreatedAt(LocalDateTime.now());
                    }
                    if (file.getUpdatedAt() == null) {
                        file.setUpdatedAt(LocalDateTime.now());
                    }

                    project.addFile(file);
                    return Optional.of(codeFileRepository.save(project));
                }
            }
        } catch (NumberFormatException e) {
            return Optional.empty();
        }

        return Optional.empty();
    }

    public Optional<CodeProject> updateFile(String projectId, String filename, String newContent, String userId) {
        try {

            Long longId = Long.parseLong(projectId);
            Optional<CodeProject> projectOpt = codeFileRepository.findById(longId);

            if (projectOpt.isPresent()) {
                CodeProject project = projectOpt.get();

                for (CodeFile file : project.getFiles()) {
                    if (file.getFilename().equals(filename)) {
                        // Save current version before updating
                        System.out.println(">>> userId = " + userId);
                        System.out.println(">>> filename = " + filename);
                        System.out.println(">>> content = " + newContent);
                        System.out.println(">>> file.getContent() = " + file.getContent());
                        System.out.println(">>> is history null? " + (file.getHistory() == null));

                        file.addVersion(userId);

                        // Update content
                        file.setContent(newContent);
                        file.setUpdatedAt(LocalDateTime.now());
                        return Optional.of(codeFileRepository.save(project));
                    }
                }
            }
        } catch (NumberFormatException e) {
            System.out.println("🔥🔥🔥 Error in updateFile:");
            e.printStackTrace();


        }

        return Optional.empty();
    }


    @Transactional
    public boolean deleteFile(String projectId, String filename) {
        try {
            Long longId = Long.parseLong(projectId);
            Optional<CodeProject> projectOpt = codeFileRepository.findById(longId);

            if (projectOpt.isPresent()) {
                CodeProject project = projectOpt.get();
                boolean removed = project.getFiles().removeIf(file -> file.getFilename().equals(filename));

                if (removed) {
                    codeFileRepository.save(project);
                    return true;
                }
            }
        } catch (NumberFormatException e) {
            return false;
        }

        return false;
    }

    public Optional<List<CodeProject>> findUserProject(Long id) {
        return codeFileRepository.findAllByUserId(id);
    }
}